# V O I D os

## About

**⌜ V O I D os ⌟** is an **[Operating System](https://en.wikipedia.org/wiki/Operating_system)** that uses **[V O I D lang](https://github.com/voidspawner/void.lang)** to run and create applications and games.

> [!IMPORTANT]
> **The project is in the process of development.**

<img src="https://github.com/voidspawner/void.ideology/blob/main/site/image/logo.jpg" width="100%">

> [**About**](#about)・
[**Structure**](#structure)・
[**Security**](#security)・
[**How to Install**](#how-to-install)・
[**Modern & Retro**](#modern--retro)・
[**A Bit of History**](#a-bit-of-history)・
[**V O I D game**](#v-o-i-d-game)・
[**V O I D social**](#v-o-i-d-social)・
[**V O I D lang**](#v-o-i-d-lang)・
[**V O I D tech**](#v-o-i-d-tech)・
[**V O I D ideology**](#v-o-i-d-ideology)・
[**V O I D license**](#v-o-i-d-license)・
[**V O I D task**](#v-o-i-d-task)

## Structure

The operating system is in a **single file**. This makes it easy to transfer it to different devices, backup and control damage or modification.
```
os.void
```
The operating system contains viewing and editing media and office files, working with the file system, web browser, social network client and server, network routing load balancing, interfacing with peripherals, virtualization tools, AI helper, creating applications and 3D・2D games.

## Security

Each application can run in a separate isolated space, with a limited set of actions, or in a separate virtual machine, so that no data corruption or stealing occurs.

## How to Install

1. Download **[V O I D lang](https://github.com/voidspawner/void.lang)**
2. Spawn **V O I D os** on your drive
3. Boot with **V O I D os**
 
> [!NOTE]
> **``Linux・macOS``**
> ```console
> void spawner os /mnt/flash
> ```
> 
> **``Windows``**
> ```console
> void.exe spawner os f:
> ```
> 
> **``Python``**
> ```console
> python void.py spawner os /mnt/flash
> ```
>
> **``Variation``**
> ```console
> void spawner os.x86 /mnt/flash
> void spawner os.80286 /mnt/flash
> void spawner os.atari /mnt/flash
> ```

## Modern & Retro

An operating system with **V O I D lang** that can run both on **modern** and **retro** computers, as well as emulate them.

| <br><img width=1000> | [Atari 65XE](https://en.wikipedia.org/wiki/Atari_8-bit_computers)<br><img width=1000> | [IBM PC](https://en.wikipedia.org/wiki/IBM_Personal_Computer)<br><img width=1000> | [IBM PC/AT](https://en.wikipedia.org/wiki/IBM_Personal_Computer_AT)<br><img width=1000> | Modern<br><img width=1000> |
| ----------------- | ---------------------------------- | ------------------------------ | ------------------------------ | ------------------------------------ |
| **Year**          | <p align="center">1985</p>         | <p align="center">1981</p>     | <p align="center">1984</p>     | <p align="center">2025</p>           |
| **CPU**           | <p align="center">[MOS 6502](https://en.wikipedia.org/wiki/MOS_Technology_6502)</p>     | <p align="center">[Intel 8088](https://en.wikipedia.org/wiki/Intel_8088)</p> | <p align="center">[Intel 80286](https://en.wikipedia.org/wiki/Intel_80286)</p> | <p align="center">[Intel Core i9](https://www.intel.com/content/www/us/en/products/sku/232167/intel-core-i913900ks-processor-36m-cache-up-to-6-00-ghz/specifications.html)</p> |
| **CPU Released**  | <p align="center">1975</p>         | <p align="center">1979</p>     | <p align="center">1982</p>     | <p align="center">2023</p>           |
| **Transistors**   | <p align="center">3 510</p>        | <p align="center">29 000</p>   | <p align="center">134 000</p>  | <p align="center">17 800 000 000</p> |
| **Technology**    | <p align="center">8 μm</p>         | <p align="center">3 μm</p>     | <p align="center">1.5 μm</p>   | <p align="center">10 nm</p>          |
| **Architecture**  | <p align="center">8 bit</p>        | <p align="center">16 bit</p>   | <p align="center">16 bit</p>   | <p align="center">64 bit</p>         |
| **Instructions**  | <p align="center">56</p>           | <p align="center">61</p>       | <p align="center">118</p>      | <p align="center">3 684</p>          |
| **Clock Rate**    | <p align="center">1.79 Mhz</p>     | <p align="center">4.77 Mhz</p> | <p align="center">12 Mhz</p>   | <p align="center">6 GHz</p>          |
| **Data Bus**      | <p align="center">8 bit</p>        | <p align="center">16 bit</p>   | <p align="center">16 bit</p>   | <p align="center">64 bit</p>         |
| **Address Bus**   | <p align="center">16 bit</p>       | <p align="center">20 bit</p>   | <p align="center">24 bit</p>   | <p align="center">64 bit</p>         |
| **Memory**        | <p align="center">64 kb</p>        | <p align="center">64 kb</p>    | <p align="center">640 kb</p>   | <p align="center">192 Gb</p>         |
| **HDD**           | <p align="center">-</p>            | <p align="center">-</p>        | <p align="center">40 Mb</p>    | <p align="center">16 Tb</p>          |
| **Floppy**        | <p align="center">5.25"</p>        | <p align="center">5.25"</p>    | <p align="center">5.25"</p>    | <p align="center">-</p>              |
| **Cartridge**     | <p align="center">+</p>            | <p align="center">-</p>        | <p align="center">-</p>        | <p align="center">-</p>              |
| **Cassette Tape** | <p align="center">+</p>            | <p align="center">-</p>        | <p align="center">-</p>        | <p align="center">-</p>              |
| **Joystick**      | <p align="center">+</p>            | <p align="center">-</p>        | <p align="center">-</p>        | <p align="center">-</p>              |
| **Mouse**         | <p align="center">-</p>            | <p align="center">+</p>        | <p align="center">+</p>        | <p align="center">+</p>              |
| **Keyboard**      | <p align="center">+</p>            | <p align="center">+</p>        | <p align="center">+</p>        | <p align="center">+</p>              |
| **Modem**         | <p align="center">300 baud</p>     | <p align="center">300 baud</p> | <p align="center">300 baud</p> | <p align="center">-</p>              |
| **Monitor**       | <p align="center">[TV](https://en.wikipedia.org/wiki/Analog_television)</p> | <p align="center">[CGA](https://en.wikipedia.org/wiki/Color_Graphics_Adapter)</p> | <p align="center">[EGA](https://en.wikipedia.org/wiki/Enhanced_Graphics_Adapter)</p> | <p align="center">[8k](https://en.wikipedia.org/wiki/8K_resolution)</p> |
| **Width**         | <p align="center">320</p>          | <p align="center">320</p>      | <p align="center">640</p>      | <p align="center">7 680 </p>         |
| **Height**        | <p align="center">192</p>          | <p align="center">200</p>      | <p align="center">350</p>      | <p align="center">4 320</p>          |
| **Columns**       | <p align="center">40</p>           | <p align="center">80</p>       | <p align="center">80</p>       | <p align="center">-</p>              |
| **Rows**          | <p align="center">24</p>           | <p align="center">25</p>       | <p align="center">25</p>       | <p align="center">-</p>              |
| **Colors**        | <p align="center">16 (256)</p>     | <p align="center">4 (16)</p>  | <p align="center">16 (64)</p>  | <p align="center">68 719 476 736</p> |

The operating system can be written using **[Assembly](https://en.wikipedia.org/wiki/Assembly_language)** and **[C++](https://en.wikipedia.org/wiki/C++)** languages. Or with **V O I D lang** and direct use of **[opcodes](https://en.wikipedia.org/wiki/Opcode)**.

```assembly
        .org $c000    ; Starting address of the program

start   lda #<message ; Load message address
        sta $07f8     ; Set string output address
        lda #>message
        sta $07f9

        lda #13       ; Select color (text white, background black)
        jsr $e544     ; Calling system function

loop    lda message,x ; Load character from string
        beq done      ; If the character is null, terminate
        jsr $e716     ; Output the character to the screen
        inx           ; Increase string index
        bne loop      ; Go to next character

done    rts           ; Return from the program

message .byte "Hi World :D", 0 ; Message string
```

| MOS Technology 6502<br><img width=1000>  | Intel 8086<br><img width=1000>                                                                                          | Intel 80286<br><img width=1000>                   |
| ---------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------- |
| ``ADC`` Add with carry                   | ``AAA`` Adjust after Addition                                                                                           | ``AAA`` ASCII adjust for addition                 |
| ``AND`` And (with accumulator)           | ``AAD`` ASCII Adjust before Division                                                                                    | ``AAD`` ASCII adjust for division                 |
| ``ASL`` Arithmetic shift left            | ``AAM`` ASCII Adjust after Multiplication                                                                               | ``AAM`` ASCII adjust for multiply                 |
| ``BCC`` Branch on carry clear            | ``AAS`` ASCII Adjust after Subtraction                                                                                  | ``AAS`` ASCII adjust for subtraction              |
| ``BCS`` Branch on carry set              | ``ADC`` Add with Carry                                                                                                  | ``ADC`` Add byte or word with carry               |
| ``BEQ`` Branch on equal (zero set)       | ``ADD`` Add                                                                                                             | ``ADD`` Add byte or word                          |
| ``BIT`` Bit test                         | ``AND`` Logical AND between all bits of two operands                                                                    | ``AND`` "And" byte or word                        |
| ``BMI`` Branch on minus (negative set)   | ``CALL`` Transfers control to procedure                                                                                 | ``BOUND`` Detects values outside prescribed range |
| ``BNE`` Branch on not equal (zero clear) | ``CBW`` Convert byte into word                                                                                          | ``CALL`` Call procedure                           |
| ``BPL`` Branch on plus (negative clear)  | ``CLC`` Clear Carry flag                                                                                                | ``CBW`` Convert byte to word                      |
| ``BRK`` Break / interrupt                | ``CLD`` Clear Direction flag                                                                                            | ``CLC`` Clear carry flag                          |
| ``BVC`` Branch on overflow clear         | ``CLI`` Clear Interrupt enable flag                                                                                     | ``CLD`` Clear direction flag                      |
| ``BVS`` Branch on overflow set           | ``CMC`` Complement Carry flag                                                                                           | ``CLI`` Clear interrupt enable flag               |
| ``CLC`` Clear carry                      | ``CMP`` Compare                                                                                                         | ``CMC`` Complement carry flag                     |
| ``CLD`` Clear decimal                    | ``CMPSB`` Compare bytes: ES:[DI] from DS:[SI]                                                                           | ``CMP`` Compare byte or word                      |
| ``CLI`` Clear interrupt disable          | ``CMPSW`` Compare words: ES:[DI] from DS:[SI]                                                                           | ``CMPS`` Compare byte or word string              |
| ``CLV`` Clear overflow                   | ``CWD`` Convert Word to Double word                                                                                     | ``CWD`` Convert word to doubleword                |
| ``CMP`` Compare (with accumulator)       | ``DAA`` Decimal adjust After Addition                                                                                   | ``DAA`` Decimal adjust for addition               |
| ``CPX`` Compare with X                   | ``DAS`` Decimal adjust After Subtraction                                                                                | ``DAS`` Decimal adjust for subtraction            |
| ``CPY`` Compare with Y                   | ``DEC`` Decrement                                                                                                       | ``DEC`` Decrement byte or word by 1               |
| ``DEC`` Decrement                        | ``DIV`` Unsigned divide                                                                                                 | ``DIV`` Divide byte or word unsigned              |
| ``DEX`` Decrement X                      | ``HLT`` Halt the System                                                                                                 | ``ENTER`` Format stack for procedure entry        |
| ``DEY`` Decrement Y                      | ``IDIV`` Signed divide                                                                                                  | ``ESC`` Escape to extension processor             |
| ``EOR`` Exclusive or (with accumulator)  | ``IMUL`` Signed multiply                                                                                                | ``HLT`` Halt until interrupt or reset             |
| ``INC`` Increment                        | ``IN`` Input from port into AL or AX                                                                                    | ``IDIV`` Integer divide byte or word              |
| ``INX`` Increment X                      | ``INC`` Increment                                                                                                       | ``IMUL`` Integer multiply byte or word            |
| ``INY`` Increment Y                      | ``INT`` Interrupt numbered by immediate byte (0..255)                                                                   | ``IN`` Input byte or word                         |
| ``JMP`` Jump                             | ``INTO`` Interrupt 4 if Overflow flag is 1                                                                              | ``INC`` Increment byte or word by 1               |
| ``JSR`` Jump subroutine                  | ``IRET`` Interrupt Return                                                                                               | ``INS`` Input bytes or word string                |
| ``LDA`` Load accumulator                 | ``JA`` Short Jump if first operand is Above second operand (as set by CMP instruction)                                  | ``INT`` Interrupt                                 |
| ``LDX`` Load X                           | ``JAE`` Short Jump if first operand is Above or Equal to second operand (as set by CMP instruction)                     | ``INTO`` Interrupt if overflow                    |
| ``LDY`` Load Y                           | ``JB`` Short Jump if first operand is Below second operand (as set by CMP instruction)                                  | ``IRET`` Interrupt return                         |
| ``LSR`` Logical shift right              | ``JBE`` Short Jump if first operand is Below or Equal to second operand (as set by CMP instruction)                     | ``JA`` Jump if above                              |
| ``NOP`` No operation                     | ``JC`` Short Jump if Carry flag is set to 1                                                                             | ``JAE`` Jump if above or equal                    |
| ``ORA`` Or with accumulator              | ``JCXZ`` Short Jump if CX register is 0                                                                                 | ``JB`` Jump if below                              |
| ``PHA`` Push accumulator                 | ``JE`` Short Jump if first operand is Equal to second operand (as set by CMP instruction)                               | ``JBE`` Jump if below or equal                    |
| ``PHP`` Push processor status (SR)       | ``JG`` Short Jump if first operand is Greater then second operand (as set by CMP instruction)                           | ``JC`` Jump if carry                              |
| ``PLA`` Pull accumulator                 | ``JGE`` Short Jump if first operand is Greater or Equal to second operand (as set by CMP instruction)                   | ``JCXZ`` Jump if register CX = 0                  |
| ``PLP`` Pull processor status (SR)       | ``JL`` Short Jump if first operand is Less then second operand (as set by CMP instruction)                              | ``JE`` Jump if equal                              |
| ``ROL`` Rotate left                      | ``JLE`` Short Jump if first operand is Less or Equal to second operand (as set by CMP instruction)                      | ``JG`` Jump if greater                            |
| ``ROR`` Rotate right                     | ``JMP`` Unconditional Jump. Transfers control to another part of the program                                            | ``JGE`` Jump if greater or equal                  |
| ``RTI`` Return from interrupt            | ``JNA`` Short Jump if first operand is Not Above second operand (as set by CMP instruction)                             | ``JL`` Jump if less                               |
| ``RTS`` Return from subroutine           | ``JNAE`` Short Jump if first operand is Not Above and Not Equal to second operand (as set by CMP instruction)           | ``JLE`` Jump if less or equal                     |
| ``SBC`` Subtract with carry              | ``JNB`` Short Jump if first operand is Not Below second operand (as set by CMP instruction)                             | ``JMP`` Jump                                      |
| ``SEC`` Set carry                        | ``JNBE`` Short Jump if first operand is Not Below and Not Equal to second operand (as set by CMP instruction)           | ``JNA`` Jump if not above                         |
| ``SED`` Set decimal                      | ``JNC`` Short Jump if Carry flag is set to 0                                                                            | ``JNAE`` Jump if not above nor equal              |
| ``SEI`` Set interrupt disable            | ``JNE`` Short Jump if first operand is Not Equal to second operand (as set by CMP instruction)                          | ``JNB`` Jump if not below                         |
| ``STA`` Store accumulator                | ``JNG`` Short Jump if first operand is Not Greater then second operand (as set by CMP instruction)                      | ``JNBE`` Jump if not below nor equal              |
| ``STX`` Store X                          | ``JNGE`` Short Jump if first operand is Not Greater and Not Equal to second operand (as set by CMP instruction)         | ``JNC`` Jump if not carry                         |
| ``STY`` Store Y                          | ``JNL`` Short Jump if first operand is Not Less then second operand (as set by CMP instruction)                         | ``JNE`` Jump if not equal                         |
| ``TAX`` Transfer accumulator to X        | ``JNLE`` Short Jump if first operand is Not Less and Not Equal to second operand (as set by CMP instruction)            | ``JNG`` Jump if not greater                       |
| ``TAY`` Transfer accumulator to Y        | ``JNO`` Short Jump if Not Overflow                                                                                      | ``JNGE`` Jump if not greater nor equal            |
| ``TSX`` Transfer stack pointer to X      | ``JNP`` Short Jump if No Parity (odd)                                                                                   | ``JNL`` Jump if not less                          |
| ``TXA`` Transfer X to accumulator        | ``JNS`` Short Jump if Not Signed (if positive)                                                                          | ``JNLE`` Jump if not less nor equal               |
| ``TXS`` Transfer X to stack pointer      | ``JNZ`` Short Jump if Not Zero (not equal)                                                                              | ``JNO`` Jump if not overflow                      |
| ``TYA`` Transfer Y to accumulator        | ``JO`` Short Jump if Overflow                                                                                           | ``JNP`` Jump if not parity                        |
|                                          | ``JP`` Short Jump if Parity (even)                                                                                      | ``JNS`` Jump if not sign                          |
|                                          | ``JPE`` Short Jump if Parity Even                                                                                       | ``JNZ`` Jump if not zero                          |
|                                          | ``JPO`` Short Jump if Parity Odd                                                                                        | ``JO`` Jump if overflow                           |
|                                          | ``JS`` Short Jump if Signed (if negative)                                                                               | ``JP`` Jump if parity                             |
|                                          | ``JZ`` Short Jump if Zero (equal)                                                                                       | ``JPE`` Jump if parity even                       |
|                                          | ``LAHF`` Load AH from 8 low bits of Flags register                                                                      | ``JPO`` Jump if parity odd                        |
|                                          | ``LDS`` Load memory double word into word register and DS                                                               | ``JS`` Jump if sign                               |
|                                          | ``LEA`` Load Effective Address                                                                                          | ``JZ`` Jump if zero                               |
|                                          | ``LES`` Load memory double word into word register and ES                                                               | ``LAHF`` Load AH register from flags              |
|                                          | ``LODSB`` Load byte at DS:[SI] into AL                                                                                  | ``LDS`` Load pointer using DS                     |
|                                          | ``LODSW`` Load word at DS:[SI] into AX                                                                                  | ``LEA`` Load effective address                    |
|                                          | ``LOOP`` Decrease CX, jump to label if CX not zero                                                                      | ``LEAVE`` Restore stack for procedure exit        |
|                                          | ``LOOPE`` Decrease CX, jump to label if CX not zero and Equal (ZF = 1)                                                  | ``LES`` Load pointer using ES                     |
|                                          | ``LOOPNE`` Decrease CX, jump to label if CX not zero and Not Equal (ZF = 0)                                             | ``LMSW`` Load machine status word                 |
|                                          | ``LOOPNZ`` Decrease CX, jump to label if CX not zero and ZF = 0                                                         | ``LOCK`` Lock bus during next instruction         |
|                                          | ``LOOPZ`` Decrease CX, jump to label if CX not zero and ZF = 1                                                          | ``LODS`` Load byte or word string                 |
|                                          | ``MOV`` Copy operand2 to operand1                                                                                       | ``LOOP`` Loop                                     |
|                                          | ``MOVSB`` Copy byte at DS:[SI] to ES:[DI]. Update SI and DI                                                             | ``LOOPE`` Loop if equal                           |
|                                          | ``MOVSW`` Copy word at DS:[SI] to ES:[DI]. Update SI and DI                                                             | ``LOOPNE`` Loop if not equal                      |
|                                          | ``MUL`` Unsigned multiply                                                                                               | ``LOOPNZ`` Loop if not zero                       |
|                                          | ``NEG`` Negate. Makes operand negative                                                                                  | ``LOOPZ`` Loop if zero                            |
|                                          | ``NOP`` No Operation                                                                                                    | ``MOV`` Move byte or word                         |
|                                          | ``NOT`` Invert each bit of the operand                                                                                  | ``MOVS`` Move byte or word string                 |
|                                          | ``OR`` Logical OR between all bits of two operands                                                                      | ``MUL`` Multiply byte or word unsigned            |
|                                          | ``OUT`` Output from AL or AX to port                                                                                    | ``NEG`` Negate byte or word                       |
|                                          | ``POP`` Get 16 bit value from the stack                                                                                 | ``NOP`` No operation                              |
|                                          | ``POPF`` Get flags register from the stack                                                                              | ``NOT`` "Not" byte or word                        |
|                                          | ``PUSH`` Store 16 bit value in the stack                                                                                | ``OR`` "Inclusive or" byte or word                |
|                                          | ``PUSHF`` Store flags register in the stack                                                                             | ``OUT`` Output byte or word                       |
|                                          | ``RCL`` Rotate operand1 left through Carry Flag                                                                         | ``OUTS`` Output bytes or word string              |
|                                          | ``RCR`` Rotate operand1 right through Carry Flag                                                                        | ``POP`` Pop word off stack                        |
|                                          | ``REP`` Repeat following MOVSB, MOVSW, LODSB, LODSW, STOSB, STOSW instructions CX times                                 | ``POPA`` Pop all registers from stack             |
|                                          | ``REPE`` Repeat following CMPSB, CMPSW, SCASB, SCASW instructions while ZF = 1 (result is Equal), maximum CX times      | ``POPF`` Pop flags off stack                      |
|                                          | ``REPNE`` Repeat following CMPSB, CMPSW, SCASB, SCASW instructions while ZF = 0 (result is Not Equal), maximum CX times | ``PUSH`` Push word onto stack                     |
|                                          | ``REPNZ`` Repeat following CMPSB, CMPSW, SCASB, SCASW instructions while ZF = 0 (result is Not Zero), maximum CX times  | ``PUSHA`` Push all registers on stack             |
|                                          | ``REPZ`` Repeat following CMPSB, CMPSW, SCASB, SCASW instructions while ZF = 1 (result is Zero), maximum CX times       | ``PUSHF`` Push flags onto stack                   |
|                                          | ``RET`` Return from near procedure                                                                                      | ``RCL`` Rotate through carry left byte or word    |
|                                          | ``RETF`` Return from Far procedure                                                                                      | ``RCR`` Rotate through carry right byte or word   |
|                                          | ``ROL`` Rotate operand1 left                                                                                            | ``REP`` Repeat                                    |
|                                          | ``ROR`` Rotate operand1 right                                                                                           | ``REPE`` Repeat while equal                       |
|                                          | ``SAHF`` Store AH register into low 8 bits of Flags register                                                            | ``REPNE`` Repeat while not equal                  |
|                                          | ``SAL`` Shift Arithmetic operand1 Left                                                                                  | ``REPNZ`` Repeat while not not zero               |
|                                          | ``SAR`` Shift Arithmetic operand1 Right                                                                                 | ``REPZ`` Repeat while zero                        |
|                                          | ``SBB`` Subtract with Borrow                                                                                            | ``RET`` Return from procedure                     |
|                                          | ``SCASB`` Compare bytes: AL from ES:[DI]                                                                                | ``ROL`` Rotate left byte or word                  |
|                                          | ``SCASW`` Compare words: AX from ES:[DI]                                                                                | ``ROR`` Rotate right byte or word                 |
|                                          | ``SHL`` Shift operand1 Left                                                                                             | ``SAHF`` Store AH register in flags               |
|                                          | ``SHR`` Shift operand1 Right                                                                                            | ``SAR`` Shift arithmetic right byte or word       |
|                                          | ``STC`` Set Carry flag                                                                                                  | ``SBB`` Subtract byte or word with borrow         |
|                                          | ``STD`` Set Direction flag                                                                                              | ``SCAS`` Scan byte or word string                 |
|                                          | ``STI`` Set Interrupt enable flag                                                                                       | ``SHR`` Shift logical right byte or word          |
|                                          | ``STOSB`` Store byte in AL into ES:[DI]                                                                                 | ``SMSW`` Store machine status word                |
|                                          | ``STOSW`` Store word in AX into ES:[DI]                                                                                 | ``STC`` Set carry flag                            |
|                                          | ``SUB`` Subtract                                                                                                        | ``STD`` Set direction flag                        |
|                                          | ``TEST`` Logical AND between all bits of two operands for flags only                                                    | ``STI`` Set interrupt enable flag                 |
|                                          | ``XCHG`` Exchange values of two operands                                                                                | ``STOS`` Store byte or word string                |
|                                          | ``XLATB`` Translate byte from table                                                                                     | ``SUB`` Subtract byte or word                     |
|                                          | ``XOR`` Logical XOR (Exclusive OR) between all bits of two operands                                                     | ``TEST`` "Test" byte or word                      |
|                                          |                                                                                                                         | ``WAIT`` Wait for BUSY not active                 |
|                                          |                                                                                                                         | ``XCHG`` Exchange byte or word                    |
|                                          |                                                                                                                         | ``XLAT`` Translate byte                           |
|                                          |                                                                                                                         | ``XOR`` "Exclusive or" byte or word               |

## A Bit of History

The first computers were just **advanced calculators**. Intel's first processor **[4004](https://en.wikipedia.org/wiki/Intel_4004)** was designed to run the **[Busicom](https://en.wikipedia.org/wiki/Busicom)** calculator. To operate such a calculator, the Operating System was a programming language. Thus the **[IBM 5100](https://en.wikipedia.org/wiki/IBM_5100)** operating system was represented by two languages **[BASIC](https://en.wikipedia.org/wiki/BASIC)** and **[APL](https://en.wikipedia.org/wiki/APL_(programming_language))** (for working with matrix and other scientific calculations).

<img src="https://i.imgur.com/aZP4voi.jpeg" height=250> <img src="https://i.imgur.com/cf2aFtE.jpeg" height=250>

**[Retroinformática: IBM 5100 (1975)](https://www.neoteo.com/retroinformatica-ibm-5100-1975/)**

Later operating systems extended their file handling functionality. **[Unix](https://ru.wikipedia.org/wiki/Unix)**, **[CP/M](https://en.wikipedia.org/wiki/CP/M)**, **[DOS](https://en.wikipedia.org/wiki/DOS)** were simplified versions of programming languages for working with the file system.

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/DEC_VT100_terminal.jpg/1024px-DEC_VT100_terminal.jpg" width=400>

**[DEC VT100 3 KB RAM (1978)](https://en.wikipedia.org/wiki/VT100)**

And even later, with the appearance of multitasking operating systems, applications began to use operating system **API** calls to access devices and display **user interface** (UI).

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e3/Macintosh_128k_transparency.png/640px-Macintosh_128k_transparency.png" height=270> <img src="https://upload.wikimedia.org/wikipedia/commons/7/79/Computer_macintosh_128k%2C_1984_%28all_about_Apple_onlus%29.jpg" height=270> <img src="https://upload.wikimedia.org/wikipedia/commons/3/34/Macintosh-motherboard.jpg" height=270>

**[Macintosh 128K (1984)](https://en.wikipedia.org/wiki/Macintosh_128K)**

Computer technology is continually evolving.

| Type                     | Name                                                                                    | Year                           |
| -----------------------  | --------------------------------------------------------------------------------------- | ------------------------------ |
| **Calculating**          | [**Abacus**](https://en.wikipedia.org/wiki/Abacus)                                      | <p align="center">2500 BC</p>  |
| **Print**                | [**Johannes Gutenberg's Printing Press**](https://en.wikipedia.org/wiki/Printing_press) | <p align="center">1440</p>     |
| **Programmatic Control** | [**Jacquard Machine**](https://en.wikipedia.org/wiki/Jacquard_machine)                  | <p align="center">1804</p>     |
| **Multiplying**          | [**Arithmometer**](https://en.wikipedia.org/wiki/Arithmometer)                          | <p align="center">1820</p>     |
| **Programming Language** | [**Short Code**](https://en.wikipedia.org/wiki/Short_Code_(computer_language))          | <p align="center">1950</p>     |
| **OS**                   | [**GM-NAA I/O**](https://en.wikipedia.org/wiki/GM-NAA_I/O)                              | <p align="center">1956</p>     |
| **Game**                 | [**Spacewar!**](https://en.wikipedia.org/wiki/Spacewar!)                                | <p align="center">1962</p>     |
| **Multitasking OS**      | [**PDP-6**](https://en.wikipedia.org/wiki/PDP-6)                                        | <p align="center">1964</p>     |
| **Graphical OS**         | [**Alto Executive**](https://en.wikipedia.org/wiki/Xerox_Alto)                          | <p align="center">1973</p>     |
| **Network**              | [**Ethernet for Xerox Alto**](https://en.wikipedia.org/wiki/Ethernet)                   | <p align="center">1973</p>     |
| **CPU**                  | [**Intel 8086**](https://en.wikipedia.org/wiki/Intel_8086)                              | <p align="center">1978</p>     |
| **Spreadsheet**          | [**VisiCalc**](https://en.wikipedia.org/wiki/VisiCalc)                                  | <p align="center">1979</p>     |
| **3D Game**              | [**Battlezone**](https://en.wikipedia.org/wiki/Battlezone_(1980_video_game))            | <p align="center">1980</p>     |
| **HTTP Server**          | [**CERN httpd**](https://en.wikipedia.org/wiki/CERN_httpd)                              | <p align="center">1990</p>     |
| **Web Browser**          | [**WorldWideWeb**](https://en.wikipedia.org/wiki/WorldWideWeb)                          | <p align="center">1990</p>     |
| **Encoding**             | [**Unicode**](https://en.wikipedia.org/wiki/Unicode)                                    | <p align="center">1991</p>     |
| **Data Compression**     | [**Gzip**](https://en.wikipedia.org/wiki/Gzip)                                          | <p align="center">1992</p>     |
| **Web Language**         | [**JavaScript**](https://en.wikipedia.org/wiki/JavaScript)                              | <p align="center">1995</p>     |
| **Social Network**       | [**SixDegrees**](https://en.wikipedia.org/wiki/SixDegrees.com)                          | <p align="center">1997</p>     |
| **Web Data Format**      | [**JSON**](https://en.wikipedia.org/wiki/JSON)                                          | <p align="center">1999</p>     |
| **3D Craft Game**        | [**Minecraft**](https://en.wikipedia.org/wiki/Minecraft)                                | <p align="center">2009</p>     |
| **AI**                   | [**Stable Diffusion**](https://en.wikipedia.org/wiki/Stable_Diffusion)                  | <p align="center">2022</p>     |
| **Ideology**             | [**V O I D**](https://github.com/voidspawner/void.ideology)                             | <p align="center">2023</p>     |

Now it has come to the point where applications can be created in simple descriptive language **V O I D lang**, and all the complex functionality residing directly in the **V O I D os**.

## V O I D game
**[⌜ V O I D game ⌟](https://voidsp.ru/void.game)** is a game that creates an **infinite** number of games, v-apps and content.

## V O I D social
**⌜ V O I D social ⌟** is a social network where you can **quickly** and **easily** communicate without words with people all over the world.

## V O I D lang
**[⌜ V O I D lang ⌟](https://github.com/voidspawner/void.lang)** is the language for rapidly creating applications in the **[V O I D](https://github.com/voidspawner/void.lang#v-o-i-d-format)** or **[JSON](https://en.wikipedia.org/wiki/JSON)** format. It is used as a replacement for both the standard Bash/CMD/etc. languages and for writing **UI Applications**, **Servers** and **Games**. The language uses one of the languages already preinstalled in the system. So you don't need to install anything else. Code and data are not separated. So the whole application fits in **one V O I D or JSON file**. Since the **code is presented as data**, applications can be easily generated with **AI**, updated, installed and launched remotely.

## V O I D tech
**[⌜ V O I D tech ⌟](https://github.com/voidspawner/void.tech)** are combinable devices controlled by **[V O I D ai](https://github.com/voidspawner/void.lang#v-o-i-d-ai)** for creating **individual** stand-alone productions, as well as creating individual products with **unique designs** and in the required quantities.

## V O I D ideology
**[⌜ V O I D ⌟](https://github.com/voidspawner/void.ideology)**  is not only about compact technologies, but also an **ideology** that shows where these technologies are taking us.

## V O I D license
**⌜ V O I D license ⌟** is a license to distribute digital content and goods. Expressed in a single sentence:

> **DO WHAT YOU WANT**

You can use it in both **private** and **open source**, embed it in **free** or **paid** products. **Modify**. Create your **own solutions** based on it. **No need to specify the author**.

## V O I D task
> [!IMPORTANT]
> By adding your code to the repository, you are publishing it under the **V O I D licence**.

Find out current **tasks** and **payment** at [**V O I D task**](https://voidsp.ru/void.task)
